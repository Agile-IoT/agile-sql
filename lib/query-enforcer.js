
var util = require('./util')
var createError = require('http-errors');
var log = require('winston')

/**
 * Creates a new instance of QueryEnforcer.
 * This class evaluates policies by relying on agile-security
 * @constructor QueryEnforcer
 * @param {Object} agile - agile-sdk object used to check policies
 * @param {Object} conf - object containing the database configuration
 * @param {Object} mapping - object containing mapping between read and write actions and SQL keywords such as INSERT, DELETE, etc. Usually loaded from conf folder.
 */

var QueryEnforcer = function (agile, conf, mapping) {
  this.agile = agile
  this.dbId = util.dbId(conf)
  this.mapping = mapping
}


/**
* @summary This function receives an object with actions and tables,
* as the one returned by sqlparser.parseQueryIntoActionsOnTables and evaluates
* whether the current user can execute the query
* @name evaluatePolicy
* @public
* @function
* @memberof  QueryEnforcer
* @returns {Promise}
* @param {Object} tablesAffected -argument as returned by sqlparser.parseQueryIntoActionsOnTables
* @fulfil {void} resolves if the sql query can be ejecuted, or rejects with an error otherwise.
* For additional information, what happens under the hood is that for each table affected the agile.pdp is called.
* For example, if the tablesAffected argument has  {"DELETE":[],"CREATE":[],"MERGE":[],"UPSERT":[],"UPDATE":[],"INSERT":[],"REPLACE":[],"SELECT":["user"]},
* Then, assuming a database with id (autogenerated by the configurator based on host and dbname)
* "sql-db-mysql", the call to the pdp would contain the following body:
* {"entityId":"sql-db-mysql","entityType":"database","field":"actions.tables.user","method":"read"}
* This evaluates whether the table user can be read by the user currently logged in
* @example
* enforcer.evaluatePolicy(tablesAffected).then(function(results) {
*   console.log(results);
* });
**/
QueryEnforcer.prototype.evaluatePolicy = function(parseResults){
  var that = this;
  return new Promise(function (resolve, reject) {
    let query = []
    that.checkParseResults(parseResults).then((ops) =>{
      if(Object.keys(ops).length < 0){
        resolve()
      }
      else{
        Object.keys(ops).forEach((op)=>{
          let listOfTables = ops[op]
          listOfTables.forEach((name)=>{
            query.push({
              entityId: that.dbId,
              entityType: 'database',
              field:`actions.tables.${name}`,
              method: op
            })
          })
        })
        log.debug(`pdp query is ${JSON.stringify(query)}`)
        return that.agile.policies.pdp.evaluate(query)
      }
    }).then((pdpRes)=>{
      log.debug(`pdp query result is ${JSON.stringify(pdpRes)}`)
      let accumulator = true;
      pdpRes.forEach((value)=>{
        accumulator = accumulator && value
      })
      log.debug(`result of merging all policies with and : ${JSON.stringify(accumulator)}`)
      if(accumulator){
        resolve()
      } else {
        reject(createError(403, "access denied"))
      }

    }).catch((error)=>{
      if(error.statusCode){
        reject(error)
      }
      else if(error.response && error.response.status && error.response.statusText){
        reject(createError(error.response.status, error.response.statusText))
      }
      else {
        log.error(`error in enforcer ${JSON.stringify(Object.keys(error))}`)
        reject(createError(500,error))
      }
    })
  })
}


 /**
 * @summary This function receives an object with actions and tables,
 * as the one returned by sqlparser.parseQueryIntoActionsOnTables and resolves with
 * an Object containing the actions and the tables affected in order to use this later
 * for the policy evaluation.
 * @name checkParseResults
 * @public
 * @function
 * @memberof  QueryEnforcer
 * @param {Object} tablesAffected -argument as returned by sqlparser.parseQueryIntoActionsOnTables
 * @returns {Promise}
 * @fulfil {Object} with the keys "read" and "write" where each key contains an array
 * of table names affected by read or writes respectively.
 * Following the example of usage from the sql parser, if
 * the folowing object mapping SQL statements to tables:
 * {"DELETE":[],"CREATE":[],"MERGE":[],"UPSERT":[],"UPDATE":[],"INSERT":[],"REPLACE":[],"SELECT":["user"]}
 * would yield the following result from this function * {"read":["user"]} as the SELECT is a read action on the table user.
 * @example
 * enforcer.checkParseResults(tablesAffected).then(function(results) {
 *   console.log(results);
 * });
 **/
QueryEnforcer.prototype.checkParseResults = function (parseResults) {
  var that = this
  return new Promise(function (resolve, reject) {
    let accumulator = {}
    Object.keys(parseResults).forEach((currentValue)=>{
      let done = false
      Object.keys(that.mapping).forEach((k)=>{
        if(that.mapping[k].indexOf(currentValue)>=0){
          done = true
          if(parseResults[currentValue].length>0 ){
            accumulator[k] = accumulator[k] || []
            accumulator[k] = accumulator[k].concat(parseResults[currentValue]);
          }
        }
      })
      if(!done){
        reject(createError(400, "unknown SQL keyword currentValue"+k))
      }
    })
    log.debug(`result of accumulating actions and mapping them to read and writes : ${JSON.stringify(accumulator)}`)
    resolve(accumulator)
  })
}

module.exports = QueryEnforcer
